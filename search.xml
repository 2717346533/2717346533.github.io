<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Test050]]></title>
    <url>%2F2019%2F10%2F03%2FTest050%2F</url>
    <content type="text"><![CDATA[以后的路今天和微信的翻译交流群里面的前辈交流，一个有一两年工作经验的可以干活的python后端程序员在北京一个月15K 打算：这份工作不想干到明年毕业了。争取达到实习证明，然后一两个月之内走人，目标地：深圳 眼下 今天解决了将图片放进源码编辑器和scratch里面没办法删除白色部分的难题 办法：使用美图秀秀抠图，然后自动抠图，接着将背景设置为透明 机构这几天连续都有课，有点吃不消 交流今天和大神们交流果然开拓眼界，还是要好好学习 科班用一个星期就能学好Flask让我有点触不及防 总结：目前先学好Flask这一个框架，然后学习 计算机基础：数据结构与算法，计算机网络，计算机组成原理，操作系统 争取这个月看完计算机基础和做完这个项目吧 10号前看完数据结构 16号之前看完计算机网络 22号之前看完计算机组成原理 28号之前看完操作系统 Flask将admin的后台网页布置好了 今天布置了管理员登陆页面 学习使用装饰器 做到P19 12345678910# 使用的库from flask import render_template, redirect, url_for, flash, session, requestfrom app.admin.forms import LoginFormfrom functools import wrapsfrom flask_wtf import FlaskFormfrom wtforms import StringField, PasswordField, SubmitFieldfrom wtforms.validators import DataRequired,ValidationError# 请求方法GET POST]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test049]]></title>
    <url>%2F2019%2F10%2F02%2FTest049%2F</url>
    <content type="text"><![CDATA[总结 python_Flask微电影网站搭建，目的在于熟悉Flask框架 前几天解决了Flask和mysql连接的问题到现在没有出现其他问题，这个项目应该能顺利完成 目前做到P15 今日成果 完成了前台搜索页面的代码编写 404页面代码 后台首页 后台标签管理 添加标签 标签列表 后台电影管理 添加电影 电影管理 预告管理 添加预告 预告列表 学了点jinjia2语法 123456789101112131415161718192021222324#添加模板&#123;% extends &quot;xxx/xxx.html&quot; %&#125;#for循环&#123;% for v in range(1,11) %&#125;&#123;% endfor %&#125;#添加内容&#123;% block content %&#125;&#123;% endblock %&#125;#添加js&#123;% block js %&#125;&#123;% endblock %&#125;#添加css&#123;% block css %&#125;&#123;% endblock %&#125;#文件路径方式1&#123;&#123; url_for(&apos;xxx.xxx&apos;) &#125;&#125;#文件路径方式2&#123;&#123; url_for(&apos;xxx&apos;,filename=&apos;xxx/xxx/xxx&apos;) &#125;&#125; 三年之约和两个女人的三年之约，看来我得加快我的步伐了 三年以后回村 三年以后娶老婆]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test048]]></title>
    <url>%2F2019%2F10%2F01%2FTest048%2F</url>
    <content type="text"><![CDATA[解决啦终于解决了P7的Flask与Mysql数据库连接的问题 方法总结： 换了编辑器，没有使用虚拟环境的编辑器 没有导入和应用pymysql库 中间uuid和auths也出了点问题，不过我删除重新编写就没事了 目前做到P10，注册页面完成！]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test047]]></title>
    <url>%2F2019%2F09%2F30%2FTest047%2F</url>
    <content type="text"><![CDATA[没有尽力学习的一天 把《大染坊》看完了 flask的微电影出了bug，做不出来了，只好找别的Flask项目了 Flask中文文档 flask-&gt;老男孩系列视频P3 公司杂事 实习证明 3号和4号排课时 5号讲放烟花]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>懒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test046]]></title>
    <url>%2F2019%2F09%2F27%2FTest046%2F</url>
    <content type="text"><![CDATA[mysql中，事务其实是一个最小的不可分割的工作单元，事务能够保证一个业务的完整性比如我们的银行转账： 1234567a -&gt; -100update user set money = money - 100 where name = &apos;a&apos;;b -&gt; +100update user set money = money + 100 where name = &apos;b&apos;; 实际的程序中，如果只有一条语句执行成功，而另外一条没有执行成功？ 出现数据前后不一致 123update user set money = money - 100 where name = &apos;a&apos;;update user set money = money + 100 where name = &apos;b&apos;; 多条sql语句，要么同时成功，要么同时失败 mysql中如何控制事务？mysql 默认是开启事务的默认事务开启的作用是？ 当我们去执行一个sql语句的时候，效果会立即体现出来，且不能回滚 123456789create database bank;create table user( id int primary key, name varchar(20), money int);insert into user values(1,&apos;a&apos;,1000); 事务回滚：撤销sql语句执行效果1rollback; 设置mysql自动提交为false1set autocommit=0; 总结: 自动提交？@@aotocommit=1 手动提交? commit; 事务回滚? rollback; 如果这个时候转账： 1234update user set money = money - 100 where name = &apos;a&apos;;update user set money = money + 100 where name = &apos;b&apos;;rollback; 事务给我们提供一个返回的机会 begin; 或者 start transaction;都可以帮我们手动开启一个事务(手动开启事务) 123456789# 方式1begin;update user set money = money - 100 where name = &apos;a&apos;;update user set money = money + 100 where name = &apos;b&apos;;# 方式2start transaction;update user set money = money - 100 where name = &apos;a&apos;;update user set money = money + 100 where name = &apos;b&apos;; 总结： 事务开启之后，一旦commit提交，就不可回滚（当前事务在提交后结束） 事务的四大特征A 原子性：事务是最小的单位，不可以在分割C 一致性：事务要求，同一事务中的sql语句，必须保证同时成功或者同时失败I 隔离性： 事务1和事务2 之间是具有隔离性的read uncommitted; 读未提交如果有事务a和事务b a事务对数据操作，在操作的过程中，事务没有被提交，但是b可以看见a操作的结果 1234bank数据库 user表insert into user values(3,&apos;小明&apos;,1000);insert into user values(4,&apos;小黑&apos;,1000); 如何查看数据库的隔离级别 12mysql 8.0;select @@global.transaction_isolation; 如何修改隔离级别？ 1set global transaction isolation level read uncommitted; 转账：小明给小黑：800块钱 小明 -&gt; 银行账户 小黑 -&gt; 银行账户 123start transaction;update user set money = money - 800 where name = &apos;小明&apos;;update user set money = money + 800 where name = &apos;小黑&apos;; 小黑请客吃饭，花了1800,发现账户钱不够 原因：小明rollback; 总结： 如果两个不同的地方，都在进行操作，如果事务a开启之后，他的数据可以被其他事务读取到 这样就会出现（脏读） 脏读：一个事务读取到另一个事务没有提交的数据，就叫做脏读 实际开发是不允许脏读出现的 read commited; 读已经提交12345678910111213141516171819202122232425#修改隔离级别set global transaction isolation level read committed;#查看隔离级别select @@global.transaction_isolation;bank数据库 user表小张：银行的会计start transaction;select * from user;小张出去上厕所。。抽烟小王：start transaction;insert into user values(5,&apos;c&apos;,100);commit;小王上完厕所，抽完烟回来select avg(money) from user;money的平均值不是1000,变少了？虽然我只能读到另一个事务提交的数据，但还是会出现问题读取同一个表的数据，发现前后不一致不可重复读现象：read committed repeatable read; 可以重复读12345678910111213141516#修改隔离级别set global transaction isolation level repeatable read;#查看隔离级别select @@global.transaction_isolation;张全蛋，成都start transaction;王尼玛，北京start transaction;张全蛋，成都insert into user values(6,&apos;d&apos;,1000);王尼玛，北京-插入数据出错insert into user values(6,&apos;d&apos;,1000); 这种现象就叫做幻读！！ 事务a和事务b,同时操作一张表，事务a提交的数据，也不能被事务b读到，就可以造成幻读 serializable; 串行化1234567891011121314151617181920212223242526272829#修改隔离级别set global transaction isolation level serializable;#查看隔离级别select @@global.transaction_isolation;张全蛋，成都start transaction;王尼玛，北京start transaction;张全蛋，成都insert into user values(7,&apos;赵铁足&apos;,1000);张全蛋，成都start transaction;insert into user values(8,&apos;王小花&apos;,1000);sql语句会被卡住了当user表被另外一个事务操作的时候，其他事务里面的写操作，是不可以进行的进入排队状态（串行化），直到王尼玛那边的事务结束之后，张全蛋这边的写入操作才会执行在没有等待超时的情况下王尼玛，北京commit;张全蛋，成都Query OK, 1 row affected (37.27 sec)串行化问题是：性能特性差！！！ 总结： read uncommitted-&gt;read commited-&gt;repeatable read-&gt;serializable 隔离级别越高，性能越差 mysql默认隔离级别是repeatable read D 持久性：事务一旦结束，就不可以返回事务开启：修改默认提交1set autocommit=0; begin;start transaction;事务手动提交：1commit; 事务手动回滚：1rollback; finally:B站Mysql基础语句的视频看完啦]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test045]]></title>
    <url>%2F2019%2F09%2F27%2FTest045%2F</url>
    <content type="text"><![CDATA[内连接inner join 或者join(交集) 1234567891011121314151617181920212223242526272829创建两个表create table person( id int, name varchar(20), cardId int);create table card( id int, name varchar(20));insert into card values(1,&apos;饭卡&apos;);insert into card values(2,&apos;建行卡&apos;);insert into card values(3,&apos;农行卡&apos;);insert into card values(4,&apos;工商卡&apos;);insert into card values(5,&apos;邮政卡&apos;);insert into person values(1,&apos;张三&apos;,1);insert into person values(2,&apos;李四&apos;,3);insert into person values(3,&apos;王五&apos;,6);# 并没有创建外键inner join 查询内联查询，其实就是两张表中的数据,通过某个字段相对，查询出相关记录数据select * from person inner join card on person.cardId=card.id; 外连接 左连接 left join 或者 left outer join 1select * from person left join card on person.cardId=card.id; 左外连接，会把左边表里面的所有数据取出来，而右边表中的数据，如果有相等的，就显示出来 如果没有，就会补NULL 右连接 right join 或者 right outer join 1select * from person right join card on person.cardId=card.id; 右外连接，会把右边表里面的所有数据取出来，而左边表中的数据，如果有相等的，就显示出来 如果没有，就会补NULL 完全外连接 full join 或者 full outer join 1select * from person full join card on person.cardId=card.id; mysql不支持full join]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>SQL的四种连接查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test044]]></title>
    <url>%2F2019%2F09%2F26%2FTest044%2F</url>
    <content type="text"><![CDATA[查询和学号为108，101的同学同年出生的所有学生的sno,sname和sbirthday列1select * from student where year(sbirthday) in (select year(sbirthday) from student where sno in(108,101)); 查询“张旭”教师任课的学生成绩1select degree from score where cno=(select cno from course where tno = (select tno from teacher where tname=&quot;张旭&quot;)); 查询选修某课程的同学人数多余3人的教师姓名123insert into score values(&apos;101&apos;,&apos;3-105&apos;,&apos;90&apos;); #填充数据select tname from teacher where tno=(select tno from course where cno=(select cno from score group by cno having count(*)&gt;3)); 查询95036班全体学生的记录123insert into student values(&apos;110&apos;,&apos;关羽&apos;,&apos;女&apos;,&apos;1997-07-05&apos;,&apos;95036&apos;);select * from student where class in (&apos;95036&apos;); 查询存在有85分以上成绩的课程Cno1select cno,degree from score where degree&gt;85; 查询出“计算机系”教师所教课程的成绩表1select cno,degree from score where cno in (select cno from course where tno in (select tno from teacher where depart=&quot;计算机系&quot;)); 查询“计算机系”与“电子工程系”不同职称的教师的tname和prof123select * from teacher where depart=&apos;计算机系&apos; and prof not in (select prof from teacher where depart=&apos;电子工程系&apos;)unionselect * from teacher where depart=&apos;电子工程系&apos; and prof not in (select prof from teacher where depart=&apos;计算机系&apos;); 查询选修编号为“3-105”课程且成绩至少高于选修编号为“3-245”的同学的Cno,Sno和Degree,按Degree从高到低次序排序1234select * from score where cno=&apos;3-105&apos; and degree&gt;any(select degree from score where cno=&apos;3-245&apos;)order by degree desc; 查询选修编号为“3-105”且成绩高于选修编号为“3-245”课程的同学Cno,Sno和Degree123select * from score where cno=&apos;3-105&apos; and degree&gt;all(select degree from score where cno=&apos;3-245&apos;); 查询所有教师和同学的name,sex和birthday123select sname as name,ssex as sex,sbirthday as birthday from studentunionselect tname,tsex,tbrithday from teacher; 查询所有女教师和女同学的name,sex和birthday123select sname as name,ssex as sex,sbirthday as birthday from student where ssex = &apos;女&apos;unionselect tname,tsex,tbrithday from teacher where tsex = &apos;女&apos;; 查询成绩比该课程平均成绩低的同学的成绩表1select * from score a where degree &lt; (select avg(degree) from score b where a.cno=b.cno); 查询所有任课教师的tname和depart1select tname,depart from teacher where tno in (select tno from course); 查询至少有2名男生的班号1select class from student where ssex =&apos;男&apos; group by class having count(*)&gt;1; 查询student表中不姓“百”的同学记录1select * from student where sname not like &apos;百%&apos;; 查询student表中每个学生的姓名和年龄1select sname,year(now())-year(sbirthday) as age from student; 查询student表中最大和最小的sbirthday日期值1select max(sbirthday) as &apos;Max&apos;,min(sbirthday) as &apos;Min&apos; from student; 以班号和年龄从大到小的顺序查询student表中的全部记录1select * from student order by class desc,sbirthday; 查询男教师以及所上的课程1select * from course where tno in(select tno from teacher where tsex=&apos;男&apos;); 查询最高分同学的sno cno和degree列1select * from score where degree = (select max(degree) from score); 查询和”李军”同性别的所有同学的Sname1select sname from student where ssex=(select ssex from student where sname=&apos;李军&apos;); 查询和”李军”同性别并同班的同学Sname123select sname from student where ssex=(select ssex from student where sname=&apos;百度&apos;)and class=(select class from student where sname=&apos;百度&apos;); 查询所有选修”计算机导论”课程的”男”同学的成绩表123select * from score where cno=(select cno from course where cname=&apos;计算机导论&apos;)and sno in(select sno from student where ssex=&apos;男&apos;); 现查询所有学生的sno,cno和grade列12345678910111213# 假设使用如下命令建立一个grade表：create table grade( low int(3), upp int(3), grade char(1) );insert into grade values(90,100,&apos;A&apos;);insert into grade values(80,89,&apos;B&apos;);insert into grade values(70,79,&apos;C&apos;);insert into grade values(60,69,&apos;D&apos;);insert into grade values(0,59,&apos;E&apos;);select sno,cno,grade from score,grade where degree between low and upp;]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>查询练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test043]]></title>
    <url>%2F2019%2F09%2F25%2FTest043%2F</url>
    <content type="text"><![CDATA[学生表1234567create table student( sno varchar(20) primary key, sname varchar(20) not null, ssex varchar(10) not null, sbirthday datetime, class varchar(20)); 教师表12345678create table teacher( tno varchar(20) primary key, tname varchar(20) not null, tsex varchar(10) not null, tbrithday datetime, prof varchar(20) not null, depart varchar(20) not null); 课程表123456create table course( cno varchar(20) primary key, cname varchar(20) not null, tno varchar(20) not null, foreign key(tno) references teacher(tno)); 成绩表12345678create table score( sno varchar(20) not null, cno varchar(20) not null, degree decimal, foreign key(sno) references student(sno), foreign key(cno) references course(cno), primary key(sno,cno)); 添加学生表123456789insert into student values(&apos;101&apos;,&apos;百度&apos;,&apos;男&apos;,&apos;1997-08-03&apos;,&apos;95033&apos;);insert into student values(&apos;102&apos;,&apos;腾讯&apos;,&apos;男&apos;,&apos;1996-08-03&apos;,&apos;95031&apos;);insert into student values(&apos;103&apos;,&apos;网易&apos;,&apos;女&apos;,&apos;1994-08-03&apos;,&apos;95033&apos;);insert into student values(&apos;104&apos;,&apos;抖音&apos;,&apos;男&apos;,&apos;1993-08-03&apos;,&apos;95033&apos;);insert into student values(&apos;105&apos;,&apos;爱奇艺&apos;,&apos;女&apos;,&apos;1998-08-03&apos;,&apos;95031&apos;);insert into student values(&apos;106&apos;,&apos;土豆&apos;,&apos;女&apos;,&apos;1997-08-03&apos;,&apos;95031&apos;);insert into student values(&apos;107&apos;,&apos;搜狐&apos;,&apos;男&apos;,&apos;1997-08-03&apos;,&apos;95033&apos;);insert into student values(&apos;108&apos;,&apos;颤巍巍&apos;,&apos;女&apos;,&apos;1999-08-03&apos;,&apos;95031&apos;);insert into student values(&apos;109&apos;,&apos;硬邦邦&apos;,&apos;男&apos;,&apos;1994-08-03&apos;,&apos;95031&apos;); 添加教师表1234insert into teacher values(&apos;804&apos;,&apos;李城&apos;,&apos;男&apos;,&apos;1958-12-02&apos;,&apos;副教授&apos;,&apos;计算机系&apos;);insert into teacher values(&apos;856&apos;,&apos;张旭&apos;,&apos;男&apos;,&apos;1969-03-12&apos;,&apos;讲师&apos;,&apos;电子工程系&apos;);insert into teacher values(&apos;825&apos;,&apos;王萍&apos;,&apos;女&apos;,&apos;1972-05-05&apos;,&apos;助教&apos;,&apos;计算机系&apos;);insert into teacher values(&apos;831&apos;,&apos;刘冰&apos;,&apos;女&apos;,&apos;1977-08-14&apos;,&apos;助教&apos;,&apos;电子工程系&apos;); 添加课程表1234insert into course values(&apos;3-105&apos;,&apos;计算机导论&apos;,&apos;825&apos;);insert into course values(&apos;3-245&apos;,&apos;操作系统&apos;,&apos;804&apos;);insert into course values(&apos;6-166&apos;,&apos;数字电路&apos;,&apos;856&apos;);insert into course values(&apos;9-888&apos;,&apos;高等数学&apos;,&apos;831&apos;); 添加成绩表123456789insert into score values(&apos;103&apos;,&apos;3-245&apos;,&apos;86&apos;);insert into score values(&apos;103&apos;,&apos;3-105&apos;,&apos;92&apos;);insert into score values(&apos;103&apos;,&apos;6-166&apos;,&apos;85&apos;);insert into score values(&apos;105&apos;,&apos;3-245&apos;,&apos;75&apos;);insert into score values(&apos;105&apos;,&apos;3-105&apos;,&apos;88&apos;);insert into score values(&apos;105&apos;,&apos;6-166&apos;,&apos;79&apos;);insert into score values(&apos;109&apos;,&apos;3-245&apos;,&apos;68&apos;);insert into score values(&apos;109&apos;,&apos;3-105&apos;,&apos;76&apos;);insert into score values(&apos;109&apos;,&apos;6-166&apos;,&apos;81&apos;); 查询练习查询student表中的所有记录1select * from student; 查询student表中的所有的sname,ssex和class列1select sname,ssex,class from student; 查询教师所有的单位即不重复的depart列1select distinct depart from teacher; 查询score表中成绩在60到80之间所有记录1select * from score where degree between 60 and 80; 查询区间 between…and… 1select * from score where degree &gt; 60 and degree &lt; 80; 直接使用运算符比较 查询score表中成绩为85，86或88的记录1select * from score where degree in(85,86,88); 查询student表中“95031”班或性别为为“女”的同学记录1select * from student where class=&apos;95031&apos; or ssex=&apos;女&apos;; 以class降序/升序查询student表的所有记录降序1select * from student order by class desc; 升序12select * from student order by class asc;select * from student order by class; 以cno升序，degree降序查询score表的所有记录1select * from score order by cno asc,degree desc; 查询“95031”般的学生人数1select count(*) from student where class=&apos;95031&apos;; 查询score表中最高分的学生学号和课程号1select sno,cno from score where degree=(select max(degree) from score); 查询每门课的平均成绩查询一门课1select avg(degree) from score where cno=&apos;3-105&apos;; 查询多门课(group by分组)1select cno,avg(degree) from score group by cno; 查询score表中至少有5名学生选修的并以3开头的课程的平均分数1234select cno,avg(degree),count(*) from score group by cnohaving count(cno)&gt;=2 and cno like &apos;3%&apos;; 查询分数大于70，小于90的sno列12select sno,degree from scorewhere degree&gt;70 and degree&lt;90; 查询所有学生的sname,cno和degree列(两表关联)12select sname,cno,degree from student,scorewhere student.sno = score.sno; 查询所有学生的sno,cname和degree列(两表关联)12select sno,cname,degree from course,scorewhere course.cno = score.cno; 查询所有学生的sname,cname和degree列(三表关联)123select sname,cname,degree,student.sno as stu_sno,course.cno as cou_cno from student,course,scorewhere student.sno = score.sno and course.cno = score.cno; 查询“95031”班学生每门课的平均分1234select cno,avg(degree) from score where sno in (select sno from student where class=&apos;95031&apos;) group by cno; 查询选修“3-105”课程的成绩高于“109”号同学“3-105”成绩的所有同学的记录1select * from score where cno=&apos;3-105&apos; and degree&gt;(select degree from score where sno=&apos;109&apos; and cno=&apos;3-105&apos;); 查询成绩高于学号为“109”，课程号为“3-105”的成绩的所有记录1select * from score where degree&gt;(select degree from score where sno=&apos;109&apos; and cno=&apos;3-105&apos;); B站P31]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>查询练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test042]]></title>
    <url>%2F2019%2F09%2F25%2FTest042%2F</url>
    <content type="text"><![CDATA[数据库的三大设计范式第一范式-1NF数据表中的所有字段都是不可分割的原子值 123456789create table student2( id int primary key, name varchar(20), address varchar(30));insert into student2 values(1,&apos;张三&apos;,&apos;中国广东省汕头市龙湖区星光大道1001号&apos;);insert into student2 values(2,&apos;李四&apos;,&apos;中国广东省汕头市龙湖区月光大道1002号&apos;);insert into student2 values(3,&apos;王五&apos;,&apos;中国广东省汕头市龙湖区阳光大道1003号&apos;); 字段值还可以继续拆分的，就不满足第一范式 123456789101112create table student3( id int primary key, name varchar(20), country varchar(30), province varchar(30), city varchar(30), details varchar(30));insert into student3 values(1,&apos;张三&apos;,&apos;中国&apos;,&apos;广东省&apos;,&apos;汕头市&apos;,&apos;龙湖区星光大道1001号&apos;);insert into student3 values(2,&apos;李四&apos;,&apos;中国&apos;,&apos;广东省&apos;,&apos;汕头市&apos;,&apos;濠江区月光大道1002号&apos;);insert into student3 values(3,&apos;王五&apos;,&apos;中国&apos;,&apos;广东省&apos;,&apos;汕头市&apos;,&apos;龙湖区阳光大道1003号&apos;); 范式设计的越详细，对于某些实际操作可能更好，但是不一定都是好处 第二范式-2NF 必须是满足第一范式的前提下，第二范式要求，除主键外的每一列都必须完全依赖于主键 如果要出现不完全依赖，只可能发生在联合逐渐的情况下 1234567create table myorder1( product_id int, customer_id int, product_name varchar(20), customer_name varchar(20), primary key(product_id,customer_id)); 问题？： 除主键以外的其他列，只依赖与主键的部分字段 拆表 123456789101112131415create table myorder2( order_id int primary key, product_id int, customer_id int);create table product( id int primary key, name varchar(20));create table customer( id int primary key, name varchar(20)); 分成三个表之后就满足第二范式的设计 第三范式-3NF 必须先满足第二范式，除开主键列的其他列之间不能有传递依赖关系 123456create table myorder3( order_id int primary key, product_id int, customer_id int, customer_phone varchar(15)); 要满足第三范式需要拆分为： 1234567891011create table myorder4( order_id int primary key, product_id int, customer_id int,);create table customer4( id int primary key, name varchar(20), phone varchar(15)); B站数据库Mysql视频看到P19]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>三大范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Test041]]></title>
    <url>%2F2019%2F09%2F24%2FTest041%2F</url>
    <content type="text"><![CDATA[Mysql建表约束主键约束它能够唯一确定一张表中的一条记录，也就是我们通过某个字段添加约束，就可以使得该字段不重复且不为空 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556create table user( id int primary key, name varchar(20));插入数据insert into user values(1,&apos;张三&apos;);insert into user values(1,&apos;张三&apos;);# 主键不可重复ERROR 1062 (23000): Duplicate entry &apos;1&apos; for key &apos;PRIMARY&apos;insert into user values(2,&apos;张三&apos;);Query OK, 1 row affected (0.02 sec)insert into user values(null,&apos;张三&apos;);# 主键不可为空ERROR 1048 (23000): Column &apos;id&apos; cannot be null# 联合主键,只要联合的主键值加起来不重复就可以# primary key的使用位置create table user2( id int, name varchar(20), password varchar(20), primary key(id,name) );insert into user2 values(1,&apos;张三&apos;,&apos;123&apos;);Query OK, 1 row affected (0.08 sec)insert into user2 values(1,&apos;张三&apos;,&apos;123&apos;);ERROR 1062 (23000): Duplicate entry &apos;1-张三&apos; for key &apos;PRIMARY&apos;insert into user2 values(2,&apos;张三&apos;,&apos;123&apos;);Query OK, 1 row affected (0.01 sec)insert into user2 values(1,&apos;李四&apos;,&apos;123&apos;);Query OK, 1 row affected (0.04 sec)insert into user2 values(null,&apos;李四&apos;,&apos;123&apos;);# 联合主键的任何一个都不为空ERROR 1048 (23000): Column &apos;id&apos; cannot be null# 如果我们创建表的时候，忘记创建主键约束了？改怎么办？create table user4( id int, name varchar(20));#修改表结构，添加主键alter table user4 add primary key(id);#删除主键alter table user4 drop primary key;#使用 modify 修改字段，添加约束alter table user4 modify id int primary key; 自增约束12345678create table user3( id int primary key auto_increment, name varchar(20));#重复执行，id会自动增加insert into user3 (name) values(&apos;zhangsan&apos;);insert into user3 (name) values(&apos;zhangsan&apos;); 唯一约束（约束修饰的字段的值不可以重复）12345678910111213141516171819202122232425262728293031323334353637383940create table user5( id int, name varchar(20));#修改表结构，添加唯一键alter table user5 add unique(name);insert into user5 values(1,&apos;zhangsan&apos;);insert into user5 values(1,&apos;zhangsan&apos;);ERROR 1062 (23000): Duplicate entry &apos;zhangsan&apos; for key &apos;name&apos;insert into user5 values(1,&apos;lisi&apos;);#设置唯一键的不同方法一create table user6( id int, name varchar(20), unique(name));#设置唯一键的不同方法二create table user7( id int, name varchar(20) unique);#unique(id,name)表示俩个键在一起不重复就行create table user8( id int, name varchar(20), unique(id,name));#删除唯一约束alter table user7 drop index name;#modify添加alter table user7 modify name varchar(20) unique; 总结： 建表的时候就添加约束 可以使用alter…add… alter…modify… 删除alter…drop… 非空约束（修饰的字段不能为空NULL）123456create table user9( id int, name varchar(20) not null);insert into user9 (id) values(1); 默认约束123456789create table user10( id int, name varchar(20), age int default 10 ); insert into user10(id,name) values(1,&apos;zhangsan&apos;);insert into user10 values(1,&apos;zhangsan&apos;,15); 外键约束(父表/主表，子表/副表)123456789101112131415161718192021222324252627# 班级create table classes( id int primary key, name varchar(20));# 学生表create table students( id int primary key, name varchar(20), class_id int, foreign key(class_id) references classes(id));insert into classes values(1,&apos;一班&apos;);insert into classes values(2,&apos;二班&apos;);insert into classes values(3,&apos;三班&apos;);insert into classes values(4,&apos;四班&apos;);insert into students values(1001,&apos;张三&apos;,1);insert into students values(1002,&apos;张三&apos;,2);insert into students values(1003,&apos;张三&apos;,3);insert into students values(1004,&apos;张三&apos;,4);#主表(父表)classes中没有的数据值，在副表(子表)中，是不可以使用的#主表中的记录被副表引用，是不可以被删除的insert into students values(1005,&apos;张三&apos;,5); 下面准备学习数据表设计P16]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test040]]></title>
    <url>%2F2019%2F09%2F23%2FTest040%2F</url>
    <content type="text"><![CDATA[数据库Day02B站mysql视频看到P8 查看有mysql有哪些数据库 1show databases; 选择数据库 1use databaseName; 查看数据库中都有哪些数据表 1show tables; 在数据库服务器中创建自己的数据库 1create database databaseName; 创建一个数据表 1234567create TABLE pet( name VARCHAR(20), owner VARCHAR(20), specise VARCHAR(20), sex CHAR(1), brith DATAE, death DATE ); 注意事项: (1) : var()与varchar()的区别在于var()是定常的,哪怕存储的字符串没有达到”()”中数字的上限,var()依然会占用空格来填充空间.而varchar()则是不定长的,没有达到”()”中的上限则会自动去掉后面的空格; (2) : 性别不要用:sex 要用:gender 一个是性 一个是性别; (3) :定义最后一个字段的时候不要加”,”; (4) : 上面的”VAR”,”VARCHAR”,”DATE”可以用小写.不过最好用大写来表示区分关键字,若不然也许写到后面你自己都不知道这个词是数据库中的关键字还是你自己自定义的一些数据,同时一定要用英文的标点符号也必须半角输入 查看数据表的架构 12345678describe tableName;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+ Field : 字段的名称 Type : 字段的类型,可以有int var varchar Key : 是否是关键字 如可以定义为: primary key 或者 unique key ...Default: : 若是该字段没有主动设置值的时候,该字段的默认值是什么? 增 1INSERT INTO pet VALUES(&apos;mimi&apos;,&apos;蔡蔡&apos;,&apos;cat&apos;,&apos;1&apos;,&apos;2019-01-05&apos;,null); 注意: NULL:代表的是空,表示该字段还没有数据.千万不要主动填写&apos;NULL&apos;,这代表你的字段有一个值叫做&apos;null&apos;. 删 1DELETE FROM tablesName WHRER 条件; 改 1UPDATE tableName SET 字段1=值1,字段2=值2 ... WHERE 条件; 查 1select * from tableName; 退出数据库服务器 1exit;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test039]]></title>
    <url>%2F2019%2F09%2F22%2FTest039%2F</url>
    <content type="text"><![CDATA[转弯为哪般，为了那MysqlMysql也是要学的,还是先学好Mysql再来学习Flask😔，要学的太多啦 B站6个小时的mysql学习视频，然后再学Flask]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test038]]></title>
    <url>%2F2019%2F09%2F20%2FTest038%2F</url>
    <content type="text"><![CDATA[Flask微电影网站01day机器学习1.支撑向量机SVM核函数高斯核函数gamma越大，高斯分布越窄gamma越小，高斯分布越宽2.决策树（非参数学习）可以解决分类问题天然可以解决多分类问题2.1信息熵熵在信息论中代表随机变量不确定的度量熵越大，数据的不确定性越高熵越小，数据的不确定性越低2.2基尼系数2.3CART2.4决策树的局限性3.集成学习4.随机森林5.bootsing5.1ada Bootsing5.2Gradient Bootsing5.3.Stacking(堆积) 今日总结：1.将算法谜题整合到一个仓库中2.机器学习看完 收获1.了解部分机器学习的算法只是2.更加熟练的使用github 深夜看Flask-01：151.看到P6 2.目前编辑了会员登陆后台代码 3.学了如何使用git将本地更新代码项目上传到github上 git status git add * git commit -m “更新说明” git pull (多人共同维护代码时候，拉取最新分支) git push origin master]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test37]]></title>
    <url>%2F2019%2F09%2F19%2FTest037%2F</url>
    <content type="text"><![CDATA[机器会学习？逻辑回归，只可以解决二分类问题 决策边界 规则的决策边界 直线上面分为一类，直线下面分为一类 不规则的决策边界 解决多分类问题1.OvR，one vs Rest 2.OvO，one vs one 评价分类结果 分类准确度的问题，对于极度偏斜的数据，只使用分类准确度是远远不够的 使用混淆矩阵做进一步的分析 对于二分类问题行代表真实值，列代表预测值0代表negative，1代表positive精准率precision和召回率recall]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test36]]></title>
    <url>%2F2019%2F09%2F19%2FTest036%2F</url>
    <content type="text"><![CDATA[明天是否会想起多项式回归与模型泛化 欠拟合算法所训练的模型不能完整表达数据关系 过拟合算法所训练的模型过多的表达了数据间的噪音关系 测试数据集的意义寻找泛化能力最好的地方 偏差和方差的区别 模型误差等于偏差加方差加不可避免的误差导致偏差的主要原因:对问题本身不是假设不正确 导致方差的原因，使用的模型太复杂，如高阶多项式回归 有一些算法天生是高方差的算法，如KNN（原因：非参数学习通常都是高方差算法。因为不对数据进行任何假设）有一些算法天生是高偏差算法，如线性回归（原因：参数学习通常都是高偏差算法。因为对数据具有极强的假设） 偏差和方差是矛盾的（降低偏差，会提高方差，降低方差，会提高偏差） 机器学习的主要挑战，来自于方差解决高方差的通常手段： 降低模型复杂度 减少数据维度：降噪 增加样本数 使用验证集 模型正则化 Ridge Regreesion,LASSO Regression,弹性网]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test035]]></title>
    <url>%2F2019%2F09%2F17%2FTest035%2F</url>
    <content type="text"><![CDATA[无聊的一天（勉强认真） jupyter book（终于知道这个东西的作用了，很强大） 今日看的内容（机器学习） 线性回归算法 梯度下降法 PCA主成分分析法 典型的参数学习，对比kNN，非参数学习 本身不是一个机器学习算法，是一种基于搜索的最优化方法 一个非监督的机器学习算法 只能解决解决回归问题，对比kNN，即可以解决分类问题，又可以解决回归问题 批量梯度下降法，求解速度慢，稳定 主要用于数据的降维，高纬数据向低纬数据映射 对数据有假设：线性，对比kNN，对数据有假设 随机梯度下降法，求解速度快，不稳定 多元线性回归的问题，时间复杂度高O（n的3次方）优化（O(n的2.4次方)） 小批量梯度下降法，既稳定又快速 优点：对数据具有强解释性 学习任务 看完机器学习视频 看Flask中文文档 Flask微电影网站 公司杂事 明天13：20上班，12：30出门吃饭顺便上班 周四给老板讲课 周末亲子课堂 制作周末亲自课堂活动游戏（起名：你胖你先吃） 把要去其他机构的Kitten课程内容转为scratch]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test034]]></title>
    <url>%2F2019%2F09%2F17%2FTest034%2F</url>
    <content type="text"><![CDATA[灾难始终慢我一步学习 Tornado看完了（没看懂，觉得讲的不是很好） 机器学习看到第五章的第二个视频 争取明天看完机器学习然后看Flask中文文档 Flask微电影网站 公司 周四讲课 周末上亲子课 将要去其他机构的授课内容转变为scratch 其他 合同快递给学校 玩了两局游戏 看了《继承》第二季]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test033]]></title>
    <url>%2F2019%2F09%2F16%2FTest033%2F</url>
    <content type="text"><![CDATA[Day by Day 算法谜题5_请打碎水晶（很奇怪的算法，为什么不直接使用二分法呢） Tornado看到P30 今天被老板看到我上班时间在看学习视频，下周任务有点重，哲哥让我把kitten转为scratch]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test032]]></title>
    <url>%2F2019%2F09%2F15%2FTest032%2F</url>
    <content type="text"><![CDATA[忙碌而进步缓慢的一天 算法谜题4_四皇后和八皇后代码放到github上 Tornado看到P19]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test031]]></title>
    <url>%2F2019%2F09%2F13%2FTest031%2F</url>
    <content type="text"><![CDATA[占领一座知识的领地 matplotlib Numpy Pandas 数据可视化 数值类型数据分析 不同数据类型的数据分析，比如字符串和时间序列 散点，条形，直方，折线图 多维度数组（矩阵） Series一维，带标签数组，DataFrame二维，Series容器 接下来是Tornado]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test030]]></title>
    <url>%2F2019%2F09%2F12%2FTest030%2F</url>
    <content type="text"><![CDATA[进击的蜗牛 今天把《编程的乐趣》的第1，2，3道算法谜题上传到github gitbook下载好，准备翻译PEP333 数据分析看到pandasP30]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test029]]></title>
    <url>%2F2019%2F09%2F11%2FTest029%2F</url>
    <content type="text"><![CDATA[matplotlib 公司 自己学习 其他 学习顺序 今天连续做了三个小项目，抽奖，编程猫切月饼，嫦娥追兔 数据分析P14 呼吸边缘有3D眩晕玩不了 数据分析P15 开业没啥人 看懂公司《编程的乐趣》第三个谜题（发布到github） 不买没存条了 Tornado pep 333 翻译（gitbook） Flask中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test028]]></title>
    <url>%2F2019%2F09%2F10%2FTest028%2F</url>
    <content type="text"><![CDATA[快乐并累的一天 约会 重新安装树莓派的系统，为了加进去新的wifi(完成) 半夜收到老板的突然无缘无故加班的请求（完成） 买显示器（完成） 01：40下载《呼吸边缘》好像很有趣的样子 没有学习的一天]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test027]]></title>
    <url>%2F2019%2F09%2F09%2FTest027%2F</url>
    <content type="text"><![CDATA[Find a new target 完成的事 进行的事 Flask看完 看pandas_numpy_matplotlib|P4 树莓派的组装和使用电脑的VNC viewer直接无线操控 看Tornado 制定了新计划 使用gitbook编写翻译的PEP_8和PEP_333 看Flask中文文档，做出自己的Flask微电影网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test026]]></title>
    <url>%2F2019%2F09%2F08%2FTest026%2F</url>
    <content type="text"><![CDATA[树莓派是吃的么？ 树莓派组装和烧入系统 Flask第十章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test025]]></title>
    <url>%2F2019%2F09%2F07%2FTest025%2F</url>
    <content type="text"><![CDATA[小小的改变，大大的梦想 python_Flask第七章 买了树莓派 打算去健身房办卡]]></content>
  </entry>
  <entry>
    <title><![CDATA[Text024]]></title>
    <url>%2F2019%2F09%2F05%2FTest024%2F</url>
    <content type="text"><![CDATA[不屈的坚持Flask第五章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test023]]></title>
    <url>%2F2019%2F09%2F04%2FTest023%2F</url>
    <content type="text"><![CDATA[怀着旧时的梦向新大陆蜗行 这周学习Flask python核心编程看完 c++虚幻引擎的蓝图基本使用 买树莓派 回顾]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test022]]></title>
    <url>%2F2019%2F09%2F03%2FTest022%2F</url>
    <content type="text"><![CDATA[蜗牛的胜利app爬取看完了，可是好像学不会，这几天超级想买树莓派，又想学习unreal engine,又想，， 目标模糊了。Anyway，完成了一件小事 接下来把《python核心编程》看完]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test021]]></title>
    <url>%2F2019%2F09%2F01%2FTest021%2F</url>
    <content type="text"><![CDATA[蜗牛的速度app爬取第七章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test020]]></title>
    <url>%2F2019%2F08%2F29%2FTest020%2F</url>
    <content type="text"><![CDATA[在路上 app抓取第六章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test019]]></title>
    <url>%2F2019%2F08%2F27%2FTest019%2F</url>
    <content type="text"><![CDATA[扬帆起航 python核心编程P154 app抓取第五章 1app_spider(&quot;douguomeishi_fail&quot;) video book day app_spider Python core programm 01 section5 P154]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test018]]></title>
    <url>%2F2019%2F08%2F27%2FTest018%2F</url>
    <content type="text"><![CDATA[状态还是不能回家，一回家节奏就乱了，这几天都不知道在干嘛 ，也没有学习了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test017]]></title>
    <url>%2F2019%2F08%2F22%2FTest017%2F</url>
    <content type="text"><![CDATA[悬崖勒马 俯卧撑60个 python爬虫基础B站视频P38 做了一个python试听课（小星星亮晶晶） 刷抖音的时间不少 把公司不要的旧办公椅搬到宿舍，发现螺丝没带，房东也没忘记带答应过的螺丝刀]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test016]]></title>
    <url>%2F2019%2F08%2F19%2FTest016%2F</url>
    <content type="text"><![CDATA[a 约会 和潮州小妹妹约会 使徒行者2不好看 臭屁妹的水果早餐，寿司午餐很delicious]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test015]]></title>
    <url>%2F2019%2F08%2F17%2FTest015%2F</url>
    <content type="text"><![CDATA[回家 第一和第二天学习kitten 第三天学习python 第四天学习box和unity 第五天学习rpgmaker 试讲课自我感觉表现不好 python学习拉下了。接下来准备学习app抓取 1print(&quot;hello Beijing&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test014]]></title>
    <url>%2F2019%2F08%2F11%2FTest014%2F</url>
    <content type="text"><![CDATA[Fly 今天要去首都，未来几天可能更新不了了 感冒还没好全 学习任务 app爬取，然后爬取小红书 python核心编程看完 希望去北京这些事情能做完 1print(&quot;Time is so short,I must learning hard&quot;) scrapy app爬取 python_web 正则表达式 fiddler Django redis appium Flask微电影 js加解密 视频 tornado]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test013]]></title>
    <url>%2F2019%2F08%2F11%2FTest013%2F</url>
    <content type="text"><![CDATA[感冒还没好 python爬虫_从入门到精通（高级篇），看完了，最后面两个redis视频，没有做 准备学app抓取 1print(&quot;I am so tired&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test012]]></title>
    <url>%2F2019%2F08%2F09%2FTest012%2F</url>
    <content type="text"><![CDATA[New day! New start! python爬虫_从入门到精通（高级篇）,看到第39个视频 python核心编程看到第2章]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test011]]></title>
    <url>%2F2019%2F08%2F08%2FTest011%2F</url>
    <content type="text"><![CDATA[感冒 过去三天在感冒状态，没心情学习或者说没状态学习，看来平时要好好保养自己，不然感冒一次，耽误很多事 希望一年以后自己会变得更好吧 1print(&quot;I am a loser&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test010]]></title>
    <url>%2F2019%2F08%2F05%2FTest010%2F</url>
    <content type="text"><![CDATA[今天学习情况 知道scrapy怎么使用 分别同步和异步的方式使用scrapy的crawlspider对简书的推荐阅读进行全站爬取并将数据存储到mysql中，chromedriver要和chrome版本相对应（花费时间最多的，最后才知道port被我写成post,才导致一直运行不成功） redis入门学习 1print(&quot;I&apos;am learning scrapy today and crawl jianshu website!I felt excited&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test009]]></title>
    <url>%2F2019%2F08%2F03%2FTest009%2F</url>
    <content type="text"><![CDATA[scrapy学习1.scrapy视频看到第19个 2.使用scrapy的异步方式爬取汽车之家的图片，并且让图片分类 3.使用scrapy的crawlspider对汽车之家的宝马五系的多页高清图片进行爬取 4.反爬虫-随机请求头 今天一共学习了三个项目 1print(&quot;hello world&quot;)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test008]]></title>
    <url>%2F2019%2F08%2F02%2FTest008%2F</url>
    <content type="text"><![CDATA[你好，蔡银薇]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test007]]></title>
    <url>%2F2019%2F08%2F01%2FTest007%2F</url>
    <content type="text"><![CDATA[1.豆瓣的登陆界面的图形验证码换成了滑块验证码暂时没办法爬取 2.使用scrapy传统方法爬取了汽车世家的宝马5系的图片]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test006]]></title>
    <url>%2F2019%2F07%2F31%2FTest006%2F</url>
    <content type="text"><![CDATA[1.今天学习使用scrapy发送post请求登陆人人网并且跳转页面 2.准备提前开始学习app抓取了]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test005]]></title>
    <url>%2F2019%2F07%2F30%2FTest005%2F</url>
    <content type="text"><![CDATA[一.将本地仓库上传到github(已经有配置ssh密匙的情况下)1.在命令行中，输入“git init”，使Test文件夹加入git管理；2.输入“git add .”（不要漏了“.”），将Test文件夹全部内容添加到git。3.输入“git commit -m “first commit””（“git commit -m “提交信息””）4.输入（git remote add origin 你自己的https地址），连接你的guthub仓库。5.输入“git push -u origin master”，上传项目到Github。这里会要求输入Github的账号密码，按要求输入就可以。 二.将github上的项目拉取到本地1.git clone “项目的ssh或者https地址” 三.更新的本地仓库上传到github1.git add “项目名”2.git master -m “更新说明”3.git push origin master 四.微信加了一个十几人的群，有很多视频资源，听说最近要学JS加解密（估计要最近爬虫的难点） 还要求要有逆向当面的知识。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test004]]></title>
    <url>%2F2019%2F07%2F29%2FTest004%2F</url>
    <content type="text"><![CDATA[今天确定了新的目标，学习《Python高效开发实战 Django Tornado Flask Twisted》 和《Python核心编程（第3版）》，并且还有scrapy]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test003]]></title>
    <url>%2F2019%2F07%2F28%2FTest003%2F</url>
    <content type="text"><![CDATA[新的一天！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test002]]></title>
    <url>%2F2019%2F07%2F27%2FTest002%2F</url>
    <content type="text"><![CDATA[一只小可爱变成一坨粑粑的故事(●’◡’●)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Test001]]></title>
    <url>%2F2019%2F07%2F26%2FTest001%2F</url>
    <content type="text"><![CDATA[今天学会了使用hexo创建自己的博客 每天都要学习一点点！！！！]]></content>
  </entry>
</search>
